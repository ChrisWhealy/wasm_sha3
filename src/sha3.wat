;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; An implementation of the SHA3 algorithm based on the specification published as NIST FIPS 202
;; https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
;;
;; SHA3 can be used in two modes:
;;   * As a drop-in replacement for SHA2, or in
;;   * Extendable output function (XOF) mode
;;
;; This implementation focusses only on using SHA3 as a drop-in replacement for SHA2.
;; Using SHA3 in XOF mode may be implemented in the future.
;;
;; The SHA3 algorithm is fed input data that is used to manipulate its internal state.
;; The internal state is treated as a 3-dimensional matrix having the dimensions 5 * 5 * 2^l, where l is an integer in
;; the range 0..6.
;;
;; This fixes the sizes of the internal state at 25, 50, 100, 200, 400, 800 or 1600.
;;
;; Choosing values of l < 3 give state sizes that are only of value when analyzing the algorithm and should not be used
;; in practice.
;;
;; However, given we are implementing SHA3 as a SHA2 replacement, the following constraints apply:
;;   * The digest output length d generated by SHA3 must exacly match digest lengths generated by SHA2.
;;     Therefore, the d may only be one of 224, 256, 384, or 512 bits
;;   * l is fixed at 6
;;
;; Given that l = 6, the size of the internal state b is therefore fixed at 1600 (5 x 5 x 2^6 = 1600)
;;
;; The internal state is then subdivided into two regions known as the rate (of size r) and the capacity (of size c)
;; such that r + c = b.  Therefore in our case, r + c = 1600
;;
;; Further to this, the capacity c must be twice the size of the digest length d, thus c = 2d making r = 1600 - 2d
;; This gives the following permitted combinations of values for the rate r and the capacity c
;;
;; +--------+------------------------------------+----------+
;; | Digest | Permitted rate and capacity sizes  |          |
;; | length |    bits     |   bytes    |  i64s   | Security |
;; +--------+------+------+-----+------+----+----+  level   |
;; |      d |    r |    c |   r |    c |  r |  c |  (bits)  |
;; +--------+------+------+-----+------+----+----+----------+
;; |    224 | 1152 |  448 | 144 |   56 | 18 |  7 |      112 |
;; |    256 | 1088 |  512 | 136 |   64 | 17 |  8 |      128 |
;; |    384 |  768 |  832 |  96 |  104 | 12 | 13 |      192 |
;; |    512 |  576 | 1024 |  72 |  128 |  9 | 16 |      256 |
;; +--------+------+------+-----+------+----+----+----------+
;;
;; The region of the internal state called the "rate" has this name because its size determines the rate at which the
;; input data can be consumed.  Once processing has completed, the first d bits of the rate are used as the SHA3 output.
;;
;; The region of the internal state called the "capacity" is never made public and exists to create an "entropy pool"
;; into which the data bits are thoroughly mixed.
;;
;; THE "KECCAK" FUNCTION
;;
;; SHA3 manipulates the input data using a function that has been given the made up name of "Keccak".
;;
;; The Keccak function belongs to a category of functions known as "sponge" functions.  The name sponge is used because
;; like a physical sponge, this function can first "absorb" any amount of data, then "squeeze" out a result.
;;
;; What makes the SHA3 function fundamentally different from the earlier SHA functions, is that the "squeeze" operation
;; can be performed an unlimited number of times; hence, when SHA3 is used in extendable output function (XOF) mode, it
;; can act as a psuedo-random number generator.
;;
;;
;; INPUT BLOCK PADDING
;;
;; The input data is divided into some number of blocks T whose size equals that of the rate r, and where T is given by
;;
;; T = Math.floor(file_size_in_bits / r) + (file_size_in_bits mod r < 4 ? 1 : 0)
;;
;; In SHA2-replacement mode, the last block must be suffixed with the padding marker bits 01, followed by the bit
;; pattern 1[0*]1 where [0*] indicates zero or more binary zeroes as needed to fill make the block size equal to the
;; rate.  Thus, if the data in the last block is 4 or more bits smaller than the rate, the last block will be padded
;; with at least the four bits 0111.
;;
;; +------------------------+------+-------+--------+---------+---------------+
;; | Last block size (bits) | r-4  | r-5   | r-6    | r-7     | r-n           |
;; +------------------------+------+-------+--------+---------+---------------+
;; | Padding bits           | 0111 | 01101 | 011001 | 0110001 | 011[n-4 * 0]1 |
;; +------------------------+------+-------+--------+---------+---------------+
;;
;; In the event that the block size is within 3 or fewer bits of the rate, then the remaining bits are padded and a new
;; block is added as shown in the table below:
;;
;; +-------------------------+------------+-------------+--------------+---------------+
;; | Last block size (bits)  | r-3        | r-2         | r-1          | r             |
;; +-------------------------+------------+-------------+--------------+---------------+
;; | Padding bits            | 011        | 01          | 0            |               |
;; +-------------------------+------------+-------------+--------------+---------------+
;; | Contents of extra block | [r-1 * 0]1 | 1[r-2 * 0]1 | 11[r-3 * 0]1 | 011[r-4 * 0]1 |
;; +-------------------------+------------+-------------+--------------+---------------+
;;
;;
;; KECCAK-F INPUT PROCESSING
;;
;; Now that the input data has been divided into some integer number of blocks equal in size to the rate (and the last
;; of which has been appropriately padded), each input block is XOR'ed with the existing rate then the new rate and
;; capacity are passed to the Keccak function.
;;
;; let mut state: [i64; 25] = [0; 25];
;; let (rate, capacity) = state.split_at(rate_size)
;;
;; for block in 0..block_count {
;;     let data_in = input_data[block];
;;     state = keccak_f([...(rate XOR data_in), ...capacity])
;; }
;;
;; Once this loop has processed the entire input data, the "absorb" phase has completed and the output state Y(0)
;; contains the required digest.
;;
;; When SHA3 is being used in SHA2 replacement mode, the required hash value is obtained simply by taking the required
;; number of bits from the rate at Y(0).  However, when SHA3 is being used in XOF mode, at least one further round of
;; the squeeze phase is performed, yielding Y(1).  At this point you may take any number of bits from the rate (up to
;; the full size of the rate) as output, and then perform any number of further squeeze rounds to continue generating
;; psuedo-random data.
;;
;; This process is entirely deterministic.  For the same input followed by the same number of squeeze rounds, the same
;; output data will always be generated.
;;
;;                            Absorbing Phase                                             Squeezing Phase
;;  _________________________________/\________________________________  ________________________/\_____________________
;; /                                                                   \/                                               \
;;          X(0)                  X(1)                  X(T-1)               Y(0)                Y(1)                Y(x)
;;    +--+   |              +--+   |              +--+   |              +--+  ^             +--+  ^             +--+  ^
;;    |  |   |              |  |   |              |  |   |              |  |  |             |  |  |             |  |  |
;;    |  |   |              |  |   |              |  |   |              |  |  |             |  |  |             |  |  |
;;    |  |   V    +---+     |  |   V    +---+     |  |   V    +---+     |  |  |   +---+     |  |  |   +---+     |  |  |
;; r  |  | -XOR-> |   | --> |  | -XOR-> |   | --> |  | -XOR-> |   | --> |  | ---> |   | --> |  | ---> |   | --> |  | -+
;;    |  |        |   |     |  |        |   |     |  |        |   |     |  |      |   |     |  |      |   |     |  |
;;    |  |        |   |     |  |        |   |     |  |        |   |     |  |      |   |     |  |      |   |     |  |
;;    |  |        | f |     |  |        | f |     |  |        | f |     |  |      | f |     |  |      | f |     |  |
;;    +--+        |   |     +--+        |   |     +--+        |   |     +--+      |   |     +--+      |   |     +--+
;;    |  | -----> |   | --> |  | -----> |   | --> |  | -----> |   | --> |  | ---> |   | --> |  | ---> |   | --> |  |
;; c  |  |        |   |     |  |        |   |     |  |        |   |     |  |      |   |     |  |      |   |     |  |
;;    |  |        +---+     |  |        +---+     |  |        +---+     |  |      +---+     |  |      +---+     |  |
;;    +--+                  +--+                  +--+                  +--+                +--+                +--+
;;
;;
;; INDEXING CONVENTION WITHIN THE STATE ARRAY
;;
;; This module follows the state array indexing convention described in section 3.1.4 of the above document
;;                     ___ ___ ___ ___ ___
;;                   /___/___/___/___/___/|
;;                 /___/___/___/___/___/| |
;;               /___/___/___/___/___/| |/|
;;             /___/___/___/___/___/| |/| |
;;           /___/___/___/___/___/| |/| |/|
;;  ⋀   2   |   |   |   |   |   | |/| |/| |
;;  |       |___|___|___|___|___|/| |/| |/|
;;  |   1   |   |   |   |   |   | |/| |/| |
;;          |___|___|___|___|___|/| |/| |/|
;;  Y   0   |   |   |   |   |   | |/| |/| |
;;          |___|___|___|___|___|/| |/| |/   w-1   /
;;  |   4   |   |   |   |   |   | |/| |/   ...   /
;;  |       |___|___|___|___|___|/| |/   2     Z
;;  |   3   |   |   |   |   |   | |/   1     /
;;  ∨       |___|___|___|___|___|/   0     /
;;            3   4   0   1   2
;;           <------- X ------->
;;
;;
;; INNER WORKINGS OF THE KECCAK FUNCTION
;;
;; Inside the Keccak, a sequence of 5 internal functions is performed.  These internal function are identified by the
;; Greek letters Theta, Rho, Pi, Chi and Iota.
;;
;; This sequence of 5 functions is performed 12 + 2*l times
;;
;;
;;
;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(module
  (type $type_i32         (func (param i32)))
  (type $type_i32_i32     (func (param i32 i32)))
  (type $type_i32_i32_i32 (func (param i32 i32 i32)))
  (type $type_i32_i32_i64 (func (param i32 i32 i64)))

  (import "env" "debug"   (memory $debug 16))
  (import "env" "hexdump" (func $debug.hexdump (type $type_i32_i32_i32)))

  (import "log" "fnEnter"      (func $log.fnEnter      (type $type_i32)))
  (import "log" "fnExit"       (func $log.fnExit       (type $type_i32)))
  (import "log" "fnEnterNth"   (func $log.fnEnterNth   (type $type_i32_i32)))
  (import "log" "fnExitNth"    (func $log.fnExitNth    (type $type_i32_i32)))
  (import "log" "singleI64"    (func $log.singleI64    (type $type_i32_i32_i64)))
  (import "log" "singleI32"    (func $log.singleI32    (type $type_i32_i32_i32)))
  (import "log" "singleDec"    (func $log.singleDec    (type $type_i32_i32_i32)))
  (import "log" "singleBigInt" (func $log.singleBigInt (type $type_i32_i32_i64)))
  (import "log" "label"        (func $log.label        (type $type_i32)))

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; WASI requires the WASM module to export memory using the name "memory"
  ;; Memory page   1     Internal stuff
  ;; Memory pages  2     Rate and Capacity buffers
  (memory $main (export "memory") 2)

  (global $DEBUG_ACTIVE       i32 (i32.const 1))
  (global $DEBUG_IO_BUFF_PTR  i32 (i32.const 0))
  (global $FD_STDOUT          i32 (i32.const 1))
  (global $FD_STDERR          i32 (i32.const 2))
  (global $SWAP_I64_ENDIANESS v128 (v128.const i8x16 7 6 5 4 3 2 1 0 15 14 13 12 11 10 9 8))

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Memory Map: Page 1
  ;;     Offset  Length   Type    Description
  ;; 0x00000000     200   i64x24  24 Keccak round constants
  ;; 0x000000C8     100   i32x25  Rotation table for Rho function
  ;; 0x0000012C     200   i64x25  Theta A block
  ;; 0x000001F4      40   i64x5   Theta C function output
  ;; 0x0000021C      40   i64x5   Theta D function output
  ;; 0x00000244     200   i64x25  Theta function output
  ;; 0x0000030C     200   i64x25  Rho function output
  ;; 0x000003D4     200   i64x25  Pi function output
  ;; 0x0000049C     200   i64x25  Chi function output
  ;;
  (global $KECCAK_ROUND_CONSTANTS_PTR i32 (i32.const 0x00000000))
  ;; IMPORTANT
  ;; The round constant values have been deliberately added in big endian format!
  ;; This optimization avoids the need for two swizzle operations in the iota function
  (data $keccak_round_constants (memory $main) (i32.const 0x00000000)
    "\00\00\00\00\00\00\00\01" (; Round  0;) "\00\00\00\00\00\00\80\82" (; Round  1;)
    "\80\00\00\00\00\00\80\8a" (; Round  2;) "\80\00\00\00\80\00\80\00" (; Round  3;)
    "\00\00\00\00\00\00\80\8b" (; Round  4;) "\00\00\00\00\80\00\00\01" (; Round  5;)
    "\80\00\00\00\80\00\80\81" (; Round  6;) "\80\00\00\00\00\00\80\09" (; Round  7;)
    "\00\00\00\00\00\00\00\8a" (; Round  8;) "\00\00\00\00\00\00\00\88" (; Round  9;)
    "\00\00\00\00\80\00\80\09" (; Round 10;) "\00\00\00\00\80\00\00\0a" (; Round 11;)
    "\00\00\00\00\80\00\80\8b" (; Round 12;) "\80\00\00\00\00\00\00\8b" (; Round 13;)
    "\80\00\00\00\00\00\80\89" (; Round 14;) "\80\00\00\00\00\00\80\03" (; Round 15;)
    "\80\00\00\00\00\00\80\02" (; Round 16;) "\80\00\00\00\00\00\00\80" (; Round 17;)
    "\00\00\00\00\00\00\80\0a" (; Round 18;) "\80\00\00\00\80\00\00\0a" (; Round 19;)
    "\80\00\00\00\80\00\80\81" (; Round 20;) "\80\00\00\00\00\00\80\80" (; Round 21;)
    "\00\00\00\00\80\00\00\01" (; Round 22;) "\80\00\00\00\80\00\80\08" (; Round 23;)
  )

  (global $RHOTATION_TABLE i32 (i32.const 0x000000C8))
  (data (memory $main) (i32.const 0x000000C8)
    "\00\00\00\00"  (;  0;) "\24\00\00\00"  (; 36;) "\03\00\00\00"  (;  3;) "\29\00\00\00"  (; 41;) "\12\00\00\00"  (; 18;)
    "\01\00\00\00"  (;  1;) "\0A\00\00\00"  (; 10;) "\2C\00\00\00"  (; 44;) "\2D\00\00\00"  (; 45;) "\02\00\00\00"  (;  2;)
    "\3E\00\00\00"  (; 62;) "\06\00\00\00"  (;  6;) "\2B\00\00\00"  (; 43;) "\0F\00\00\00"  (; 15;) "\3D\00\00\00"  (; 61;)
    "\1C\00\00\00"  (; 28;) "\37\00\00\00"  (; 55;) "\19\00\00\00"  (; 25;) "\15\00\00\00"  (; 21;) "\38\00\00\00"  (; 56;)
    "\1B\00\00\00"  (; 27;) "\14\00\00\00"  (; 20;) "\27\00\00\00"  (; 39;) "\08\00\00\00"  (;  8;) "\0E\00\00\00"  (; 14;)
  )

  ;; Memory areas used by the inner Keccak functions
  ;; These pointers point to locations in page 1 of memory $main
  (global $THETA_A_BLK_PTR  (export "THETA_A_BLK_PTR")  i32 (i32.const 0x0000012C))  ;; Length 200
  (global $THETA_C_OUT_PTR  (export "THETA_C_OUT_PTR")  i32 (i32.const 0x000001F4))  ;; Length 40
  (global $THETA_D_OUT_PTR  (export "THETA_D_OUT_PTR")  i32 (i32.const 0x0000021C))  ;; Length 40
  (global $THETA_RESULT_PTR (export "THETA_RESULT_PTR") i32 (i32.const 0x00000244))  ;; Length 200
  (global $RHO_RESULT_PTR   (export "RHO_RESULT_PTR")   i32 (i32.const 0x0000030C))  ;; Length 200
  (global $PI_RESULT_PTR    (export "PI_RESULT_PTR")    i32 (i32.const 0x000003D4))  ;; Length 200
  (global $CHI_RESULT_PTR   (export "CHI_RESULT_PTR")   i32 (i32.const 0x0000049C))  ;; Length 200

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Memory Map: Page 2
  ;;     Offset  Length   Type    Description
  ;; 0x00010000     200  i64x25   Internal state buffer - fixed at 200 bytes or 1600 bits
  ;; 0x00010000      64   i64x8   Rate buffer
  ;; 0x00010088     136   i64x17  Capacity buffer
  (global $STATE_PTR    (export "STATE_PTR")    i32 (i32.const 0x00010000))  ;; Length fixed at 200
  (global $DATA_PTR     (export "DATA_PTR")     i32 (i32.const 0x000100C8))  ;; Length determined by the rate

  ;; Default digest size = 256, so in 64-bit words, rate = 17 and capacity = 8
  (global $DIGEST_SIZE  (export "DIGEST_SIZE")  (mut i32) (i32.const 256))
  (global $RATE         (export "RATE")         (mut i32) (i32.const 17))
  (global $CAPACITY     (export "CAPACITY")     (mut i32) (i32.const 8))
  (global $RATE_PTR     (export "RATE_PTR")          i32  (i32.const 0x00010000))  ;; Length depends on digest size
  (global $CAPACITY_PTR (export "CAPACITY_PTR") (mut i32) (i32.const 0x00010000))
  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  (func $prepare_memory
        (param $init i32)

    ;; Initialise the internal state?
    (if (local.get $init)
      (then
        (memory.fill (memory $main) (global.get $STATE_PTR) (i32.const 0) (i32.const 200))
      )
    )

    ;; Based on the required digest size, determine the size of the rate and capacity in i64 words
    (if (i32.eq (global.get $DIGEST_SIZE) (i32.const 224))
      (then
        (global.set $RATE     (i32.const 18))
        (global.set $CAPACITY (i32.const 7))
      )
      (else
        (if (i32.eq (global.get $DIGEST_SIZE) (i32.const 256))
          (then
            (global.set $RATE     (i32.const 17))
            (global.set $CAPACITY (i32.const 8))
          )
          (else
            (if (i32.eq (global.get $DIGEST_SIZE) (i32.const 384))
              (then
                (global.set $RATE     (i32.const 12))
                (global.set $CAPACITY (i32.const 13))
              )
              (else
                (global.set $RATE     (i32.const 9))
                (global.set $CAPACITY (i32.const 16))
              )
            )
          )
        )
      )
    )

    (global.set $CAPACITY_PTR (i32.add (global.get $STATE_PTR) (i32.mul (global.get $RATE) (i32.const 8)))

    (call $log.singleI32 (i32.const 10) (i32.const 0) (global.get $CAPACITY_PTR))

    ;; XOR first input block with the rate
    (call $xor_data_with_rate (i32.const 8))

    ;; Copy the internal state to $THETA_A_BLK_PTR
    (memory.copy
      (memory $main)
      (memory $main)
      (global.get $THETA_A_BLK_PTR)
      (global.get $STATE_PTR)
      (i32.const 200)
    )
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; In place XOR the 64 bytes at $RATE_PTR with the 64 bytes at $DATA_PTR
  (func $xor_data_with_rate
        (param $rate_size i32)

    (local $idx i32)

    (loop $xor_loop
      (i64.store
        (memory $main)
        (i32.add (global.get $RATE_PTR) (local.get $idx))
        (i64.xor
          (i64.load (memory $main) (i32.add (global.get $RATE_PTR) (local.get $idx)))
          (i64.load (memory $main) (i32.add (global.get $DATA_PTR) (local.get $idx)))
        )
      )

      (local.set $idx       (i32.add (local.get $idx)       (i32.const 8)))
      (local.tee $rate_size (i32.sub (local.get $rate_size) (i32.const 1)))
      (br_if $xor_loop)
    )
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  (func (export "test_theta_c")
        (param $rounds i32)
    (call $prepare_memory (i32.const 1))
    (call $theta_c (local.get $rounds))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  (func (export "test_theta_d")
    (call $prepare_memory (i32.const 1))
    (call $theta_c (i32.const 5))
    (call $theta_d)
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  (func (export "test_theta")
    (call $prepare_memory (i32.const 1))
    (call $theta)
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  (func (export "test_iota")
    (call $iota (i32.const 0))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Test a succession of the inner Keccak functions
  (func (export "test_theta_rho")
    (call $prepare_memory (i32.const 1))
    (call $theta)
    (call $rho)
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Test a succession of the inner Keccak functions
  (func (export "test_theta_rho_pi")
    (call $prepare_memory (i32.const 1))
    (call $theta)
    (call $rho)
    (call $pi)
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Test a succession of the inner Keccak functions
  (func (export "test_theta_rho_pi_chi")
    (call $prepare_memory (i32.const 1))
    (call $theta)
    (call $rho)
    (call $pi)
    (call $chi)
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Test a succession of the inner Keccak functions
  (func (export "test_theta_rho_pi_chi_iota")
    (call $prepare_memory (i32.const 1))
    (call $theta)
    (call $rho)
    (call $pi)
    (call $chi)
    (call $iota (i32.const 0))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Perform $n rounds of the Keccak function against the 64-byte block of data at $DATA_PTR
  (func (export "test_keccak")
        (param $n i32)
    (local $round i32)

    (call $prepare_memory (i32.const 1))

    (loop $next_round
      (call $keccak (local.get $round))
      (local.set $round (i32.add (local.get $round) (i32.const 1)))

      ;; If we still have more rounds to perform
      (if (local.tee $n (i32.sub (local.get $n) (i32.const 1)))
        (then
          ;; Copy the output of this round at $CHI_RESULT_PTR back to $THETA_A_BLK_PTR ready to start the next round
          (memory.copy
            (memory $main)
            (memory $main)
            (global.get $THETA_A_BLK_PTR)
            (global.get $CHI_RESULT_PTR)
            (i32.const 200)
          )
          (br $next_round)
        )
      )
    )

    ;; The output of the last Keccack round becomes the new Capacity and Rate
    (memory.copy
      (memory $main)               ;; Copy to memory
      (memory $main)               ;; Copy from memory
      (global.get $CAPACITY_PTR)   ;; Copy to address
      (global.get $CHI_RESULT_PTR) ;; Copy from address
      (i32.const 200)              ;; Length
    )

    (memory.copy
      (memory $debug)                 ;; Copy to memory
      (memory $main)                  ;; Copy from memory
      (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
      (global.get $CAPACITY_PTR)      ;; Copy from address
      (i32.const 200)                 ;; Length
    )
    (call $log.label (i32.const 5))
    (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Perform a single round of the Keccak function
  ;; The output lives at $CHI_RESULT_PTR because the iota function performs an in-place modification
  (func $keccak
        (param $round i32)
    (call $log.fnEnterNth (i32.const 9) (local.get $round))

    (memory.copy
      (memory $debug)                 ;; Copy to memory
      (memory $main)                  ;; Copy from memory
      (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
      (global.get $THETA_A_BLK_PTR)   ;; Copy from address
      (i32.const 200)                 ;; Length
    )
    (call $log.label (i32.const 4))
    (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))

    (call $theta)
    (call $rho)
    (call $pi)
    (call $chi)
    (call $iota (local.get $round))

    (call $log.fnExitNth (i32.const 9) (local.get $round))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Theta function
  ;;
  ;; Reads 200 bytes starting at $THETA_A_BLK_PTR
  ;; Writes 200 bytes to $THETA_RESULT_PTR
  ;;
  ;; C[x,z]=A[x, 0,z] ⊕ A[x, 1,z] ⊕ A[x, 2,z] ⊕ A[x, 3,z] ⊕ A[x, 4,z]
  (func $theta (export "theta")
    (call $theta_c (i32.const 5))
    (call $theta_d)
    (call $theta_xor_loop)

    ;; (memory.copy
    ;;   (memory $debug)                 ;; Copy to memory
    ;;   (memory $main)                  ;; Copy from memory
    ;;   (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
    ;;   (global.get $THETA_RESULT_PTR)  ;; Copy from address
    ;;   (i32.const 200)                 ;; Length
    ;; )
    ;; (call $log.label (i32.const 6))
    ;; (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Theta C function
  ;; Perform n rounds of $theta_c_inner
  ;; The output of each $theta_c_inner call is written as a successive i64 starting at $THETA_C_OUT_PTR
  ;;
  ;; The parameter $n is only needed to test a single round of $theta_c_inner.
  ;; In normal operation, this parameter is hard-coded to 5
  ;;
  ;; fn theta_c() {
  ;;   for x in 0..4 {
  ;;     THETA_C_PTR[x] = THETA_A_PTR[x,0] XOR
  ;;                      THETA_A_PTR[x,1] XOR
  ;;                      THETA_A_PTR[x,2] XOR
  ;;                      THETA_A_PTR[x,3] XOR
  ;;                      THETA_A_PTR[x,4]
  ;;   }
  ;; }
  (func $theta_c
        (param $n i32)
    (local $to_ptr       i32)
    (local $idx          i32)
    (local $inner_result i64)

    (call $log.fnEnter (i32.const 0))

    (local.set $to_ptr (global.get $THETA_C_OUT_PTR))

    (loop $theta_c_round
      (local.set
        $inner_result
        (call $theta_c_inner (i32.add (global.get $THETA_A_BLK_PTR) (i32.mul (local.get $idx) (i32.const 40))))
      )
      (call $log.singleI64 (i32.const 0) (i32.const 0) (local.get $inner_result))

      (i64.store (memory $main) (local.get $to_ptr) (local.get $inner_result))

      (local.set $to_ptr (i32.add (local.get $to_ptr) (i32.const 8)))
      (local.set $idx    (i32.add (local.get $idx)    (i32.const 1)))
      (local.tee $n      (i32.sub (local.get $n)      (i32.const 1)))

      (br_if $theta_c_round)
    )

    (call $log.fnExit (i32.const 0))
  )

  ;; Inner functionality of Theta C function
  ;; XOR's together the 5 i64s starting at $data_ptr
  (func $theta_c_inner
    (param $data_ptr i32)
    (result i64)

    (i64.xor
      (i64.xor
        (i64.xor
          (i64.xor
            (i64.load (memory $main) offset=0 (local.get $data_ptr)) ;; w0
            (i64.load (memory $main) offset=8 (local.get $data_ptr)) ;; w1
          )
          (i64.load (memory $main) offset=16 (local.get $data_ptr))  ;; w2
        )
        (i64.load (memory $main) offset=24 (local.get $data_ptr))    ;; w3
      )
      (i64.load (memory $main) offset=32 (local.get $data_ptr))      ;; w4
    )
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Theta D function - 5 rounds of $theta_d_inner performed against the 5 i64s at THETA_C_OUT_PTR
  ;; The output of each $theta_d_inner call is written as a successive i64 starting at $THETA_D_OUT_PTR
  ;;
  ;; fn theta_d(data_ptr: i32) {
  ;;   for idx in 0..4 {
  ;;     THETA_D_OUT_PTR[idx] = $theta_d_inner(
  ;;       $THETA_C_OUT_PTR + (((idx - 1) % 5) * 8),
  ;;       $THETA_C_OUT_PTR + (((idx + 1) % 5) * 8),
  ;;     )
  ;;   }
  ;; }
  ;;
  ;; Since the above algorithm uses fixed offsets, there is no need for a loop or modulo operations
  (func $theta_d
    (local $w0 i32)
    (local $w1 i32)
    (local $w2 i32)
    (local $w3 i32)
    (local $w4 i32)

    (call $log.fnEnter (i32.const 2))

    (local.set $w0          (global.get $THETA_C_OUT_PTR))
    (local.set $w1 (i32.add (global.get $THETA_C_OUT_PTR) (i32.const 8)))
    (local.set $w2 (i32.add (global.get $THETA_C_OUT_PTR) (i32.const 16)))
    (local.set $w3 (i32.add (global.get $THETA_C_OUT_PTR) (i32.const 24)))
    (local.set $w4 (i32.add (global.get $THETA_C_OUT_PTR) (i32.const 32)))

    (i64.store (memory $main) offset=0  (global.get $THETA_D_OUT_PTR) (call $theta_d_inner (local.get $w4) (local.get $w1)))
    (i64.store (memory $main) offset=8  (global.get $THETA_D_OUT_PTR) (call $theta_d_inner (local.get $w0) (local.get $w2)))
    (i64.store (memory $main) offset=16 (global.get $THETA_D_OUT_PTR) (call $theta_d_inner (local.get $w1) (local.get $w3)))
    (i64.store (memory $main) offset=24 (global.get $THETA_D_OUT_PTR) (call $theta_d_inner (local.get $w2) (local.get $w4)))
    (i64.store (memory $main) offset=32 (global.get $THETA_D_OUT_PTR) (call $theta_d_inner (local.get $w3) (local.get $w0)))

    (memory.copy
      (memory $debug)                 ;; Copy to memory
      (memory $main)                  ;; Copy from memory
      (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
      (global.get $THETA_D_OUT_PTR)   ;; Copy from address
      (i32.const 40)                  ;; Length
    )
    (call $log.label (i32.const 12))
    (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 40))

    (call $log.fnExit (i32.const 2))
  )

  ;; Inner functionality of Theta D function -> $w0 XOR ($w1 ROTR 1)
  (func $theta_d_inner
        (param $w0_ptr i32)
        (param $w1_ptr i32)
        (result i64)

    (local $w0  v128)
    (local $w1  v128)
    (local $res v128)

    ;; (call $log.fnEnter (i32.const 3))

    ;; The byte order of $w1 must first be swapped to big endian before the rotate right operation can be performed
    ;; Copy the i64 argument values across both lanes of a v128 in big endian format
    (local.set $w0
      (i8x16.swizzle  ;; Swap byte order
        (i64x2.splat (i64.load (memory $main) (local.get $w0_ptr)))  ;; Copy $w0 into both 64-bit lanes
        (global.get $SWAP_I64_ENDIANESS)
      )
    )
    (local.set $w1
      (i8x16.swizzle  ;; Swap byte order
        (i64x2.splat (i64.load (memory $main) (local.get $w1_ptr)))  ;; Copy $w1 into both 64-bit lanes
        (global.get $SWAP_I64_ENDIANESS)
      )
    )

    (local.set $res
      (v128.xor
        (local.get $w0)
        ;; Rotate $w1 right by 1 bit in each 64-bit lane
        ;; Since there is no SIMD operation to rotate two 64-bit lanes in a V128, we need to shift right and then
        ;; reinstate the senior bit in each lane: hence ($w1 >>> 1) | ($w1 << 63)
        (v128.or
          (i64x2.shr_u (local.get $w1) (i32.const 1))
          (i64x2.shl   (local.get $w1) (i32.const 63))
        )
      )
    )

    ;; (call $log.fnExit (i32.const 3))
    (i64x2.extract_lane 0 (i8x16.swizzle (local.get $res) (global.get $SWAP_I64_ENDIANESS)))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; For each of the 5 i64 words at $THETA_D_OUT_PTR, XOR that word with the 5 successive i64s starting at
  ;; $THETA_A_BLK_PTR.  The output is written to $THETA_RESULT_PTR
  ;;
  ;; fn theta_xor_loop(d_fn_out: [i64; 5], a_blk: mut [i64; 25]) {
  ;;   for a_blk_idx in 0..24 {
  ;;     a_blk[a_blk_idx] = d_fn_out[a_blk_idx div 5] XOR a_blk[a_blk_idx]
  ;;   }
  ;; }
  ;;
  (func $theta_xor_loop
    (local $a_blk_idx     i32)
    (local $a_blk_ptr     i32)
    (local $a_blk_word    i64)
    (local $d_fn_word     i64)
    (local $result_ptr    i32)

    ;; (call $log.fnEnter (i32.const 4))

    (local.set $result_ptr (global.get $THETA_RESULT_PTR))
    (local.set $a_blk_ptr  (global.get $THETA_A_BLK_PTR))

    (loop $xor_loop
      (local.set $d_fn_word
        (i64.load
          (memory $main)
          (i32.add
            (global.get $THETA_D_OUT_PTR)
            ;; Convert the (A block index DIV 5) to an i64 offset by multiplying by 8
            (i32.shl (i32.div_u (local.get $a_blk_idx) (i32.const 5)) (i32.const 3))
          )
        )
      )
      (local.set $a_blk_word (i64.load (memory $main) (local.get $a_blk_ptr)))

      ;; (call $log.singleI64 (i32.const 4) (i32.const 0) (local.get $d_fn_word))
      ;; (call $log.singleI64 (i32.const 4) (i32.const 1) (local.get $a_blk_word))

      (i64.store
        (memory $main)
        (local.get $result_ptr)
        (i64.xor (local.get $d_fn_word) (local.get $a_blk_word))
      )

      (local.set $a_blk_idx  (i32.add (local.get $a_blk_idx)  (i32.const 1)))
      (local.set $a_blk_ptr  (i32.add (local.get $a_blk_ptr)  (i32.const 8)))
      (local.set $result_ptr (i32.add (local.get $result_ptr) (i32.const 8)))

      ;; Quit once all 25 words in the A block have been XOR'ed
      (br_if $xor_loop (i32.lt_u (local.get $a_blk_idx) (i32.const 25)))
    )

    ;; (call $log.fnExit (i32.const 4))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; For each of the 25 i64 words at $THETA_RESULT_PTR, rotate each word by the successive values found in the
  ;; $RHOTATION_TABLE.  The output is written to $RHO_RESULT_PTR
  ;;
  ;; fn rho(theta_out: [i64; 25]) {
  ;;   for theta_idx in 0..24 {
  ;;     rho_result[theta_idx] = ROTR(theta_out[theta_idx], $RHOTATION_TABLE[$theta_idx % 5])
  ;;   }
  ;; }
  ;;
  (func $rho (export "rho")
    (local $result_ptr i32)
    (local $theta_ptr  i32)
    (local $theta_idx  i32)
    (local $rot_ptr    i32)
    (local $rot_amt    i64)
    (local $w0         i64)

    ;; (call $log.fnEnter (i32.const 5))

    (local.set $result_ptr (global.get $RHO_RESULT_PTR))
    (local.set $rot_ptr    (global.get $RHOTATION_TABLE))
    (local.set $theta_ptr  (global.get $THETA_RESULT_PTR))

    (loop $rho_loop
      (local.set $rot_amt (i64.extend_i32_u (i32.load (memory $main) (local.get $rot_ptr))))
      ;; (call $log.singleBigInt (i32.const 5) (i32.const 2) (local.get $rot_amt))

      ;; The value must be in network byte order otherwise the rotate operation will not work correctly!
      (local.set $w0
        (i64.rotr
          (i64x2.extract_lane 0
            (i8x16.swizzle
              ;; Copy value into both 64-bit lanes
              (i64x2.splat (i64.load (memory $main) (local.get $theta_ptr)))
              (global.get $SWAP_I64_ENDIANESS)
            )
          )
          (local.get $rot_amt)
        )
      )
      ;; (call $log.singleI64 (i32.const 5) (i32.const 1) (local.get $w0))

      ;; Swizzle back to little endian byte order and store
      (i64.store
        (memory $main)
        (local.get $result_ptr)
        (i64x2.extract_lane 0
          (i8x16.swizzle
            (i64x2.splat (local.get $w0))
            (global.get $SWAP_I64_ENDIANESS)
          )
        )
      )

      (local.set $theta_ptr  (i32.add (local.get $theta_ptr)  (i32.const 8)))
      (local.set $result_ptr (i32.add (local.get $result_ptr) (i32.const 8)))
      (local.set $rot_ptr    (i32.add (local.get $rot_ptr)    (i32.const 4)))
      ;; Leave increment result on the stack for the following comparison
      (local.tee $theta_idx  (i32.add (local.get $theta_idx)  (i32.const 1)))

      ;; Quit once all 25 words in the theta result block have been rotated
      (br_if $rho_loop (i32.lt_u (i32.const 25)))
    )

    ;; (memory.copy
    ;;   (memory $debug)                 ;; Copy to memory
    ;;   (memory $main)                  ;; Copy from memory
    ;;   (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
    ;;   (global.get $RHO_RESULT_PTR)    ;; Copy from address
    ;;   (i32.const 200)                 ;; Length
    ;; )
    ;; (call $log.label (i32.const 7))
    ;; (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))

    ;; (call $log.fnExit (i32.const 5))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; Treat the 200 bytes at $RHO_RESULT_PTR as a 5x4 matrix of i64s.
  ;; Reorder these i64s according to the following transformation
  ;;
  ;; fn pi(rho_out: [i64; 25]) {
  ;;   let rho_idx = 0
  ;;
  ;;   for x in 0..4 {
  ;;     for row in 0..4 {
  ;;       let col = ((2 * x) + (3 * row)) % 5
  ;;
  ;;       pi_out[row][col] = rho_out[rho_idx]
  ;;       rho_idx += 1
  ;;     }
  ;;   }
  ;; }
  ;;
  ;; Since this algorithm results in a static reordering of the i64s, the final transformation can simply be hardcoded
  ;; rather than calculated
  (func $pi (export "pi")
    ;; (call $log.fnEnter (i32.const 6))

    (i64.store (memory $main) offset=0   (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=0   (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=64  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=8   (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=88  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=16  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=152 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=24  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=176 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=32  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=16  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=40  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=40  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=48  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=104 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=56  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=128 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=64  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=192 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=72  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=32  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=80  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=56  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=88  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=80  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=96  (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=144 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=104 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=168 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=112 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=8   (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=120 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=72  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=128 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=96  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=136 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=120 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=144 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=184 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=152 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=24  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=160 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=48  (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=168 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=112 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=176 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=136 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=184 (global.get $RHO_RESULT_PTR)))
    (i64.store (memory $main) offset=160 (global.get $PI_RESULT_PTR) (i64.load (memory $main) offset=192 (global.get $RHO_RESULT_PTR)))

    ;; (memory.copy
    ;;   (memory $debug)                 ;; Copy to memory
    ;;   (memory $main)                  ;; Copy from memory
    ;;   (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
    ;;   (global.get $PI_RESULT_PTR)     ;; Copy from address
    ;;   (i32.const 200)                 ;; Length
    ;; )
    ;; (call $log.label (i32.const 8))
    ;; (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))
    ;; (call $log.fnExit (i32.const 6))
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; The 25 i64s at $PI_RESULT_PTR are treated as 5x5 matrix, then transformed by the following function
  ;;
  ;; fn chi(pi_out: [i64; 25]) {
  ;;   let chi_idx = 0
  ;;
  ;;   for row in 0..4 {
  ;;     for col in 0..4 {
  ;;       let w0 = pi_out[row][col]
  ;;       let w1 = pi_out[(row + 1) % 5][col]
  ;;       let w2 = pi_out[(row + 2) % 5][col]
  ;;
  ;;       chi_out[chi_idx] = w0 XOR (NOT(w1) AND w2)
  ;;       chi_idx += 1
  ;;     }
  ;;   }
  ;; }
  ;;
  ;; This algorithm however simply performs a static mapping, so the transformation can be hardcoded rather than calculated
  (func $chi (export "chi")
    (local $col        i32)
    (local $row        i32)
    (local $row+1      i32)
    (local $row+2      i32)
    (local $result_ptr i32)
    (local $w0         i64)
    (local $w1         i64)
    (local $w2         i64)
    (local $chi_result i64)

    ;; (call $log.fnEnter (i32.const 7))

    (local.set $result_ptr (global.get $CHI_RESULT_PTR))

    (loop $row_loop
      ;; Reset $col counter
      (local.set $col (i32.const 0))

      ;; Calculate the current and next two row indicies
      (local.set $row+1 (i32.add (local.get $row) (i32.const 1)))
      (local.set $row+1 (select (i32.const 0) (local.get $row+1) (i32.ge_u (local.get $row+1) (i32.const 5))))

      (local.set $row+2 (i32.add (local.get $row) (i32.const 2)))
      (local.set $row+2 (select (i32.sub (local.get $row+2) (i32.const 5)) (local.get $row+2) (i32.ge_u (local.get $row+2) (i32.const 5))))

      ;; (call $log.singleI32 (i32.const 7) (i32.const 0) (local.get $row))
      ;; (call $log.singleI32 (i32.const 7) (i32.const 1) (local.get $row+1))
      ;; (call $log.singleI32 (i32.const 7) (i32.const 2) (local.get $row+2))

      (loop $col_loop
        ;; (call $log.singleI32 (i32.const 7) (i32.const 3) (local.get $col))
        ;; (call $log.singleDec (i32.const 7) (i32.const 8)
        ;;   (i32.add
        ;;     (i32.mul (local.get $row) (i32.const 5))
        ;;     (local.get $col)
        ;;   )
        ;; )

        (local.set $w0 (i64.load (memory $main) (call $chi_word_offset (local.get $row)   (local.get $col))))
        (local.set $w1 (i64.load (memory $main) (call $chi_word_offset (local.get $row+1) (local.get $col))))
        (local.set $w2 (i64.load (memory $main) (call $chi_word_offset (local.get $row+2) (local.get $col))))

        ;; (call $log.singleI64 (i32.const 7) (i32.const 4) (local.get $w0))
        ;; (call $log.singleI64 (i32.const 7) (i32.const 5) (local.get $w1))
        ;; (call $log.singleI64 (i32.const 7) (i32.const 6) (local.get $w2))

        (local.set $chi_result (call $chi_inner (local.get $w0) (local.get $w1) (local.get $w2)))
        ;; (call $log.singleI64 (i32.const 7) (i32.const 7) (local.get $chi_result))

        (i64.store (memory $main) (local.get $result_ptr) (local.get $chi_result))

        (local.set $result_ptr (i32.add (local.get $result_ptr) (i32.const 8)))
        (local.tee $col        (i32.add (local.get $col)        (i32.const 1)))
        (br_if $col_loop (i32.lt_u (i32.const 5)))
      )

      (local.tee $row (i32.add (local.get $row) (i32.const 1)))
      (br_if $row_loop (i32.lt_u (i32.const 5)))
    )

    ;; (memory.copy
    ;;   (memory $debug)                 ;; Copy to memory
    ;;   (memory $main)                  ;; Copy from memory
    ;;   (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
    ;;   (global.get $CHI_RESULT_PTR)    ;; Copy from address
    ;;   (i32.const 200)                 ;; Length
    ;; )
    ;; (call $log.label (i32.const 9))
    ;; (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))
    ;; (call $log.fnExit (i32.const 7))
  )

  ;; $w0 XOR (NOT($w1) AND $w2)
  (func $chi_inner
        (param $w0 i64)
        (param $w1 i64)
        (param $w2 i64)
        (result i64)
    (i64.xor (local.get $w0) (i64.and (i64.xor (local.get $w1) (i64.const -1)) (local.get $w2)))
  )

  ;; Transform $row and $col into a memory offset
  ;; Offset = (($row * 5) + $col) * 8
  (func $chi_word_offset
        (param $row i32)
        (param $col i32)
        (result i32)
    (i32.add
      (global.get $PI_RESULT_PTR)
      (i32.shl  ;; Multiply index by 8 to get offset
        (i32.add (i32.mul (local.get $row) (i32.const 5)) (local.get $col))  ;; Calculate index from row and column
        (i32.const 3)
      )
    )
  )

  ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ;; XOR in place the i64 at $CHI_RESULT_PTR with the supplied constant for this round of the Keccak function.
  ;;
  ;; The endianess of the first word at $CHI_RESULT_PTR can be left in network byte order as long as the round constant
  ;; is also given in network (big endian) byte order.  This avoids having to perform two swizzle operations:
  ;;   1) Swizzle network byte order -> little endian
  ;;   2) XOR the data value with the round constant
  ;;   3) Swizzle back into network byte order
  (func $iota (export "iota")
        (param $round i32)

    (local $w0         i64)
    (local $rnd_const  i64)
    (local $xor_result i64)

    ;; (call $log.fnEnter (i32.const 8))
    ;; (call $log.singleDec (i32.const 8) (i32.const 0) (local.get $round))

    ;; (memory.copy
    ;;   (memory $debug)                 ;; Copy to memory
    ;;   (memory $main)                  ;; Copy from memory
    ;;   (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
    ;;   (global.get $KECCAK_ROUND_CONSTANTS_PTR) ;; Copy from address
    ;;   (i32.const 192)                 ;; Length
    ;; )
    ;; (call $log.label (i32.const 11))
    ;; (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 192))

    (local.set $rnd_const
      (i64.load
        (memory $main)
        (i32.add
          (global.get $KECCAK_ROUND_CONSTANTS_PTR)
          (i32.shl (local.get $round) (i32.const 3)) ;; Convert the round number to an i64 offset
        )
      )
    )
    ;; (call $log.singleI64 (i32.const 8) (i32.const 1) (local.get $rnd_const))

    (local.set $w0 (i64.load (memory $main) (global.get $CHI_RESULT_PTR)))
    ;; (call $log.singleI64 (i32.const 8) (i32.const 2) (local.get $w0))

    (local.set $xor_result (i64.xor (local.get $rnd_const) (local.get $w0)))
    ;; (call $log.singleI64 (i32.const 8) (i32.const 3) (local.get $xor_result))

    (i64.store
      (memory $main)
      (global.get $CHI_RESULT_PTR)
      (local.get $xor_result)
    )

    ;; (memory.copy
    ;;   (memory $debug)                 ;; Copy to memory
    ;;   (memory $main)                  ;; Copy from memory
    ;;   (global.get $DEBUG_IO_BUFF_PTR) ;; Copy to address
    ;;   (global.get $CHI_RESULT_PTR)    ;; Copy from address
    ;;   (i32.const 200)                 ;; Length
    ;; )
    ;; (call $log.label (i32.const 10))
    ;; (call $debug.hexdump (global.get $FD_STDOUT) (global.get $DEBUG_IO_BUFF_PTR) (i32.const 200))
    ;; (call $log.fnExit (i32.const 8))
  )
)

# SHA3 Implemention in WebAssembly Text

This is a work in progress

An implementation of the SHA3 algorithm in WebAssembly Text based on the specification published as NIST FIPS 202 https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf

# Overview

The SHA3 algorithm can be used in two modes:
* As a drop-in replacement for SHA2, or in
* Extendable output function (XOF) mode

This implementation focusses only on using SHA3 as a drop-in replacement for SHA2.
Using SHA3 in XOF mode may be implemented in the future.

Given that this implementation is a drop-in replacement for SHA2, the length `d` of the generated digest must exacly match the digest lengths generated by SHA2.
Therefore, `d` may only be one of `224`, `256`, `384`, or `512` bits.

## SHA3 Internal State

The SHA3 algorithm is fed input data that is used to manipulate an internal state, referred to in some literature as an "entropy pool".

This internal state is treated as a 3-dimensional matrix having the dimensions `5 * 5 * 2^l`, where `l` is an integer in the range `0..6`.

The size (`b`) of the internal state in bits may therefore only be one of:

| `l` | Formula | Internal<br>State Size
|---|---|--:
| 0 | `5 * 5 * 2^0` | `25`
| 1 | `5 * 5 * 2^1` | `50`
| 2 | `5 * 5 * 2^2` | `100`
| 3 | `5 * 5 * 2^3` | `200`
| 4 | `5 * 5 * 2^4` | `400`
| 5 | `5 * 5 * 2^5` | `800`
| 6 | `5 * 5 * 2^6` | `1600`

Choosing a value `l < 3` give state sizes that are only of use when analyzing the algorithm's behaviour.
Such values should not be used in practice.

However, implementing SHA3 as a SHA2 replacement requires `l` to be fixed at `6`, meaning that the internal state will always be `1600` bits.

### Partitioning the Internal State

The internal state is subdivided into two regions known as the `rate` (of size `r`) and the `capacity` (of size `c`) such that `r + c = b`.  Therefore in our case, `r + c = 1600`.

The `rate` is the region into which the input data is written and from which the output digest will be taken.
It has this name because its size determines the rate at which the input data can be consumed.

The `capacity` however is never made public.  Its purpose is to acta as a hidden "entropy pool" into which the data bits in the `rate` are thoroughly mixed.

Further to this, the size `c` of the capacity must be twice the size of the output digest length `d`, thus `c = 2d` making `r = 1600 - 2d`.

Given the constraints on the output digest size `d`, the sizes of `r` and `c` may only be one of the following pairs (in bits):

| `d` | `r` | `c` | Security<br>Level
|--:|--:|--:|--:
| 224 | 1152 |  448 | 112 |
| 256 | 1088 |  512 | 128 |
| 384 |  768 |  832 | 192 |
| 512 |  576 | 1024 | 256 |


## The "Keccak" Function

SHA3 manipulates the input data using a function that has been given the made up name of "Keccak".

The Keccak function belongs to a category of functions known as "sponge" functions.
This name has been chosen because like a physical sponge, this function can first "absorb" any amount of data into its internal state, then "squeeze" out a result.

What makes the SHA3 function fundamentally different from the earlier SHA functions, is that the "squeeze" operation can be performed an unlimited number of times; hence, when SHA3 is used as an extendable output function (XOF), it can act as a psuedo-random number generator.

## Input Block Padding

The input data is divided into some number of blocks `t` of size `r`, and where `t` is given by:

```javascript
let t = Math.floor(file_size_in_bits / r) + (file_size_in_bits mod r < 4 ? 1 : 0)
```

The last block must be padded so that the data being processed fills an integer number of blocks.

The padding rules depend on whether SHA3 is being used in SHA2-replacement mode, or XOF mode.
In our case, we are only concerned with SHA2-replacement mode, so the padding rules are as follows:

* The data is suffixed with the padding marker bits `01`
* The padding marker is followed by a bit sequence that starts and ends with bit `1` and between which are zero or more bit `0`s

Thus, if the size of data `n` in the last block is 4 or more bits smaller than the rate `r`, the last block will be padded as follows:

| Size of<br>last block | Padding bits<br>last block
|---|---
| `r-4` | `0111`
| `r-5` | `01101`
| `r-6` | `011001`
| `r-7` | `0110001`
| `r-n` | `011[n-4 * 0]1`

In the event that the block size is 3 or fewer bits smaller than the rate `r`, then the remaining bits are padded using the same scheme as above, but the padding string spills over into a new block:

| Size of<br>last block | Padding bits<br>in last block | Contents of<br>extra block
|---|---|---
| `r-3` | `011` | `[r-1 * 0]1`
| `r-2` | `01` | `1[r-2 * 0]1`
| `r-1` | `0` | `11[r-3 * 0]1`
| `r` | | `011[r-4 * 0]1`

Note that if the data is an exact integer multiple of the block size `r`, then an extra block containing only the padding string is always added.

## Keccak-f Input Processing

Now that the input data has been organised into some integer number `t` of blocks of size `r` (the last of which has been appropriately padded), the "absorb" phase performs the following loop:

```rust
  // Internal state starts as 200 initialised i64s
  let mut state[i64; 200] = [0; 200];
  // Assuming a digest size of 256, the rate size in i64 words is 1088 / 64
  let rate_size = 1088 >>> 6;

  for idx in X.size {
    state = keccak_f([state[0..rate_size] XOR X[idx], ...state[rate_size..]])
  }
```

Each time a new block is read from the input data, it is `XOR`ed with the current rate and the resulting internal state passed to the Keccak function.
This process is performed as many times as needed to fully "absorb" the input data.

![Sponge function](./docs/sponge.png)

When SHA3 is being used in SHA2 replacement mode, the required hash value is obtained simply by taking the required number of bits from the rate at `Y(0)`.
However, when SHA3 is being used in XOF mode, at least one further round of the squeeze phase is performed, yielding `Y(1)`.
At this point you may take as output any number of bits from the rate (up to the full size of the rate), and then perform any number of further squeeze rounds to continue generating psuedo-random data.

This process is entirely deterministic.
For the same input followed by the same number of squeeze rounds, the same output data will always be generated.

## Indexing Convention within the Internal State Matrix

This module follows the state array indexing convention described in section 3.1.4 of the above document

![Indexing convention of internal state matrix](./docs/indexing_convention.png)
